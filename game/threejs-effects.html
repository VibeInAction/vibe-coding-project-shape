<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>几何境域：形态之战 - Three.js特效原型</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0f172a;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            z-index: 10;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .effect-button {
            @apply w-full p-3 mb-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-all duration-200 text-white font-medium;
        }
        
        .effect-button.active {
            @apply bg-blue-600 hover:bg-blue-500;
        }
        
        .slider-container {
            @apply mb-4;
        }
        
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 15px;
            z-index: 10;
            max-width: 300px;
        }
        
        /* 自定义滚动条 */
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.5);
            border-radius: 3px;
        }
        
        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.7);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- 控制面板 -->
    <div class="control-panel">
        <h2 class="text-xl font-bold mb-4 text-white">特效控制</h2>
        
        <!-- 特效选择 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">选择特效</h3>
            <button class="effect-button active" data-effect="resonance">圆环族共鸣</button>
            <button class="effect-button" data-effect="triangle">三角议会能量</button>
            <button class="effect-button" data-effect="square">方碑盟约网格</button>
            <button class="effect-button" data-effect="spiral">螺旋之子藤蔓</button>
            <button class="effect-button" data-effect="particles">粒子风暴</button>
        </div>
        
        <!-- 参数控制 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">特效参数</h3>
            
            <div class="slider-container">
                <label class="text-xs text-gray-400">强度</label>
                <input type="range" id="intensity" min="0" max="100" value="50" 
                       class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="intensityValue" class="text-xs text-gray-400">50</span>
            </div>
            
            <div class="slider-container">
                <label class="text-xs text-gray-400">速度</label>
                <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1" 
                       class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="speedValue" class="text-xs text-gray-400">1.0</span>
            </div>
            
            <div class="slider-container">
                <label class="text-xs text-gray-400">规模</label>
                <input type="range" id="scale" min="0.5" max="3" step="0.1" value="1" 
                       class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="scaleValue" class="text-xs text-gray-400">1.0</span>
            </div>
        </div>
        
        <!-- 后处理效果 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">后处理效果</h3>
            <label class="flex items-center text-sm text-gray-300 mb-2">
                <input type="checkbox" id="bloom" checked class="mr-2">
                辉光效果
            </label>
            <div class="slider-container">
                <label class="text-xs text-gray-400">辉光强度</label>
                <input type="range" id="bloomIntensity" min="0" max="3" step="0.1" value="1" 
                       class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
        
        <!-- 相机控制 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">相机控制</h3>
            <button id="resetCamera" class="effect-button">重置视角</button>
        </div>
    </div>
    
    <!-- 信息面板 -->
    <div class="info-panel">
        <h3 class="text-lg font-bold text-white mb-2">当前特效</h3>
        <p id="effectDescription" class="text-sm text-gray-300">
            圆环族共鸣效果 - 展示圆形波纹扩散和能量流动
        </p>
        <div class="mt-3 text-xs text-gray-400">
            <p>• 鼠标左键：旋转视角</p>
            <p>• 鼠标右键：平移视角</p>
            <p>• 滚轮：缩放</p>
        </div>
    </div>
    
    <script>
        // 全局变量
        let scene, camera, renderer, composer;
        let controls;
        let currentEffect = null;
        let effectObjects = [];
        
        // 特效参数
        const params = {
            intensity: 0.5,
            speed: 1.0,
            scale: 1.0,
            bloom: true,
            bloomIntensity: 1.0
        };
        
        // 初始化Three.js场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0f172a, 10, 100);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 10, 30);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 100;
            controls.minDistance = 5;
            
            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // 添加点光源
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // 创建后处理
            setupPostProcessing();
            
            // 添加网格地板
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // 初始化特效
            createResonanceEffect();
            
            // 设置事件监听
            setupEventListeners();
            
            // 开始动画循环
            animate();
        }
        
        // 设置后处理
        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.4, // radius
                0.85 // threshold
            );
            composer.addPass(bloomPass);
            
            // 保存引用以便调整
            window.bloomPass = bloomPass;
        }
        
        // 清理当前特效
        function clearCurrentEffect() {
            effectObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            effectObjects = [];
        }
        
        // 创建圆环族共鸣效果
        function createResonanceEffect() {
            clearCurrentEffect();
            
            // 创建多个同心圆环
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.RingGeometry(2 + i * 2, 2.5 + i * 2, 64);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x3b82f6,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(geometry, material);
                ring.rotation.x = Math.PI / 2;
                ring.userData = {
                    type: 'resonance',
                    index: i,
                    baseScale: 1,
                    rotationSpeed: 0.5 + i * 0.1
                };
                
                scene.add(ring);
                effectObjects.push(ring);
            }
            
            // 创建中心能量球
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x60a5fa,
                transparent: true,
                opacity: 0.8
            });
            
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.userData = {
                type: 'resonance-center',
                pulsePhase: 0
            };
            
            scene.add(sphere);
            effectObjects.push(sphere);
            
            // 创建粒子
            createResonanceParticles();
            
            updateEffectDescription('圆环族共鸣效果', '展示圆形波纹扩散和能量流动');
        }
        
        // 创建共鸣粒子
        function createResonanceParticles() {
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 3 + Math.random() * 5;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = Math.random() * 2;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                colors[i * 3] = 0.3 + Math.random() * 0.3;
                colors[i * 3 + 1] = 0.5 + Math.random() * 0.3;
                colors[i * 3 + 2] = 1.0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'resonance-particles',
                positions: positions.slice(),
                basePositions: positions.slice()
            };
            
            scene.add(particles);
            effectObjects.push(particles);
        }
        
        // 创建三角议会能量束效果
        function createTriangleEffect() {
            clearCurrentEffect();
            
            // 创建三角形框架
            const triangleGroup = new THREE.Group();
            
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * 5;
                const z = Math.sin(angle) * 5;
                
                // 创建顶点球体
                const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xef4444,
                    emissive: 0xef4444,
                    emissiveIntensity: 0.5
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(x, 0, z);
                triangleGroup.add(sphere);
                effectObjects.push(sphere);
                
                // 创建连接线
                if (i < 2) {
                    const nextAngle = ((i + 1) / 3) * Math.PI * 2 - Math.PI / 2;
                    const nextX = Math.cos(nextAngle) * 5;
                    const nextZ = Math.sin(nextAngle) * 5;
                    
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, 0, z),
                        new THREE.Vector3(nextX, 0, nextZ)
                    ]);
                    
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0xef4444,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    triangleGroup.add(line);
                    effectObjects.push(line);
                } else {
                    // 连接最后一个点
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x, 0, z),
                        new THREE.Vector3(0, 0, 5)
                    ]);
                    
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0xef4444,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    triangleGroup.add(line);
                    effectObjects.push(line);
                }
            }
            
            triangleGroup.userData = {
                type: 'triangle-frame',
                rotationSpeed: 0.2
            };
            
            scene.add(triangleGroup);
            effectObjects.push(triangleGroup);
            
            // 创建中心能量束
            const beamGeometry = new THREE.ConeGeometry(2, 10, 3);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6b6b,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.rotation.x = Math.PI;
            beam.position.y = 5;
            beam.userData = {
                type: 'triangle-beam',
                pulsePhase: 0
            };
            
            scene.add(beam);
            effectObjects.push(beam);
            
            updateEffectDescription('三角议会能量束', '展示三角形能量汇聚和释放');
        }
        
        // 创建方碑盟约网格效果
        function createSquareEffect() {
            clearCurrentEffect();
            
            // 创建网格组
            const gridGroup = new THREE.Group();
            
            // 创建多层网格
            for (let layer = 0; layer < 5; layer++) {
                const gridSize = 10 - layer * 1.5;
                const divisions = 10;
                
                const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, divisions, divisions);
                const gridMaterial = new THREE.MeshBasicMaterial({
                    color: 0x10b981,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3 - layer * 0.05
                });
                
                const grid = new THREE.Mesh(gridGeometry, gridMaterial);
                grid.rotation.x = -Math.PI / 2;
                grid.position.y = layer * 2;
                grid.userData = {
                    type: 'square-grid',
                    layer: layer,
                    rotationSpeed: 0.1 + layer * 0.05
                };
                
                gridGroup.add(grid);
            }
            
            scene.add(gridGroup);
            effectObjects.push(gridGroup);
            
            // 创建立方体核心
            const cubeGeometry = new THREE.BoxGeometry(3, 3, 3);
            const cubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x10b981,
                transparent: true,
                opacity: 0.8,
                wireframe: false
            });
            
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.y = 5;
            cube.userData = {
                type: 'square-cube',
                rotationSpeed: 0.3
            };
            
            scene.add(cube);
            effectObjects.push(cube);
            
            // 创建投影光线
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * 6;
                const z = Math.sin(angle) * 6;
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(x, 10, z),
                    new THREE.Vector3(x, 0, z)
                ]);
                
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x10b981,
                    transparent: true,
                    opacity: 0.5
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.userData = {
                    type: 'square-projection',
                    opacityPhase: Math.random() * Math.PI * 2
                };
                
                scene.add(line);
                effectObjects.push(line);
            }
            
            updateEffectDescription('方碑盟约网格投影', '展示方形网格和数字化能量场');
        }
        
        // 创建螺旋之子藤蔓效果
        function createSpiralEffect() {
            clearCurrentEffect();
            
            // 创建螺旋路径
            const spiralGroup = new THREE.Group();
            
            // 生成螺旋曲线
            const curve = new THREE.CatmullRomCurve3([]);
            const points = [];
            
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const angle = t * Math.PI * 8;
                const radius = t * 8;
                const height = t * 15;
                
                points.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                ));
            }
            
            curve.points = points;
            
            // 创建螺旋管道
            const tubeGeometry = new THREE.TubeGeometry(curve, 100, 0.3, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.6
            });
            
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.userData = {
                type: 'spiral-tube',
                pulsePhase: 0
            };
            
            spiralGroup.add(tube);
            effectObjects.push(tube);
            
            // 添加沿螺旋生长的小球
            const sphereCount = 20;
            for (let i = 0; i < sphereCount; i++) {
                const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xa78bfa,
                    emissive: 0x8b5cf6,
                    emissiveIntensity: 0.3
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.userData = {
                    type: 'spiral-sphere',
                    index: i,
                    baseScale: 1,
                    growthPhase: i * 0.3
                };
                
                spiralGroup.add(sphere);
                effectObjects.push(sphere);
            }
            
            scene.add(spiralGroup);
            effectObjects.push(spiralGroup);
            
            // 创建底部生命池
            const poolGeometry = new THREE.CylinderGeometry(10, 10, 1, 32);
            const poolMaterial = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.position.y = -0.5;
            pool.userData = {
                type: 'spiral-pool',
                pulsePhase: 0
            };
            
            scene.add(pool);
            effectObjects.push(pool);
            
            updateEffectDescription('螺旋之子藤蔓', '展示有机生长的螺旋结构和生命力');
        }
        
        // 创建粒子风暴效果
        function createParticleStormEffect() {
            clearCurrentEffect();
            
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            // 随机生成粒子位置和速度
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 20;
                const height = Math.random() * 20 - 10;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 随机速度
                velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
                
                // 随机颜色
                const colorType = Math.floor(Math.random() * 4);
                switch (colorType) {
                    case 0: // 蓝色
                        colors[i * 3] = 0.2;
                        colors[i * 3 + 1] = 0.5;
                        colors[i * 3 + 2] = 1.0;
                        break;
                    case 1: // 红色
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.3;
                        colors[i * 3 + 2] = 0.3;
                        break;
                    case 2: // 绿色
                        colors[i * 3] = 0.1;
                        colors[i * 3 + 1] = 0.7;
                        colors[i * 3 + 2] = 0.5;
                        break;
                    case 3: // 紫色
                        colors[i * 3] = 0.7;
                        colors[i * 3 + 1] = 0.4;
                        colors[i * 3 + 2] = 1.0;
                        break;
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'particle-storm',
                velocities: velocities,
                positions: positions.slice()
            };
            
            scene.add(particles);
            effectObjects.push(particles);
            
            // 创建中心漩涡
            const vortexGeometry = new THREE.TorusGeometry(5, 1, 16, 100);
            const vortexMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            
            const vortex = new THREE.Mesh(vortexGeometry, vortexMaterial);
            vortex.rotation.x = Math.PI / 2;
            vortex.userData = {
                type: 'vortex',
                rotationSpeed: 0.5
            };
            
            scene.add(vortex);
            effectObjects.push(vortex);
            
            updateEffectDescription('粒子风暴', '展示大规模粒子系统和能量漩涡');
        }
        
        // 更新特效动画
        function updateEffects(deltaTime) {
            const time = Date.now() * 0.001;
            
            effectObjects.forEach(obj => {
                if (!obj.userData) return;
                
                switch (obj.userData.type) {
                    case 'resonance':
                        // 圆环缩放动画
                        const scale = 1 + Math.sin(time * params.speed + obj.userData.index) * 0.1 * params.intensity;
                        obj.scale.set(scale * params.scale, scale * params.scale, scale * params.scale);
                        obj.material.opacity = 0.3 * params.intensity;
                        break;
                        
                    case 'resonance-center':
                        // 中心球体脉动
                        obj.userData.pulsePhase += deltaTime * params.speed;
                        const pulseScale = 1 + Math.sin(obj.userData.pulsePhase * 3) * 0.2 * params.intensity;
                        obj.scale.set(pulseScale * params.scale, pulseScale * params.scale, pulseScale * params.scale);
                        break;
                        
                    case 'resonance-particles':
                        // 粒子围绕运动
                        const positions = obj.geometry.attributes.position.array;
                        const basePositions = obj.userData.basePositions;
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            const angle = Math.atan2(basePositions[i + 2], basePositions[i]);
                            const radius = Math.sqrt(basePositions[i] * basePositions[i] + basePositions[i + 2] * basePositions[i + 2]);
                            
                            const newAngle = angle + deltaTime * params.speed * 0.5;
                            positions[i] = Math.cos(newAngle) * radius;
                            positions[i + 2] = Math.sin(newAngle) * radius;
                            positions[i + 1] += Math.sin(time * 2 + i) * 0.01 * params.intensity;
                        }
                        
                        obj.geometry.attributes.position.needsUpdate = true;
                        break;
                        
                    case 'triangle-frame':
                        // 三角形旋转
                        obj.rotation.y += deltaTime * params.speed * obj.userData.rotationSpeed;
                        break;
                        
                    case 'triangle-beam':
                        // 能量束脉动
                        obj.userData.pulsePhase += deltaTime * params.speed;
                        const beamScale = 1 + Math.sin(obj.userData.pulsePhase * 2) * 0.3 * params.intensity;
                        obj.scale.set(beamScale * params.scale, beamScale * params.scale, beamScale * params.scale);
                        obj.material.opacity = 0.6 * params.intensity;
                        break;
                        
                    case 'square-grid':
                        // 网格旋转
                        obj.rotation.z += deltaTime * params.speed * obj.userData.rotationSpeed;
                        break;
                        
                    case 'square-cube':
                        // 立方体旋转
                        obj.rotation.x += deltaTime * params.speed * obj.userData.rotationSpeed;
                        obj.rotation.y += deltaTime * params.speed * obj.userData.rotationSpeed;
                        break;
                        
                    case 'square-projection':
                        // 投影线透明度变化
                        obj.userData.opacityPhase += deltaTime * params.speed;
                        obj.material.opacity = 0.3 + Math.sin(obj.userData.opacityPhase) * 0.2 * params.intensity;
                        break;
                        
                    case 'spiral-tube':
                        // 螺旋管脉动
                        obj.userData.pulsePhase += deltaTime * params.speed;
                        const tubeOpacity = 0.6 + Math.sin(obj.userData.pulsePhase) * 0.2 * params.intensity;
                        obj.material.opacity = tubeOpacity;
                        break;
                        
                    case 'spiral-sphere':
                        // 螺旋球生长
                        obj.userData.growthPhase += deltaTime * params.speed;
                        const sphereScale = 0.5 + Math.sin(obj.userData.growthPhase) * 0.5 * params.intensity;
                        obj.scale.set(sphereScale * params.scale, sphereScale * params.scale, sphereScale * params.scale);
                        break;
                        
                    case 'spiral-pool':
                        // 生命池脉动
                        obj.userData.pulsePhase += deltaTime * params.speed;
                        const poolScale = 1 + Math.sin(obj.userData.pulsePhase * 2) * 0.1 * params.intensity;
                        obj.scale.set(poolScale * params.scale, 1, poolScale * params.scale);
                        break;
                        
                    case 'particle-storm':
                        // 粒子运动
                        const stormPositions = obj.geometry.attributes.position.array;
                        const stormVelocities = obj.userData.velocities;
                        const baseStormPositions = obj.userData.positions;
                        
                        for (let i = 0; i < stormPositions.length; i += 3) {
                            // 添加漩涡效果
                            const dx = stormPositions[i];
                            const dz = stormPositions[i + 2];
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            if (distance > 0.1) {
                                const vortexStrength = 0.02 * params.intensity;
                                stormVelocities[i] += -dz / distance * vortexStrength;
                                stormVelocities[i + 2] += dx / distance * vortexStrength;
                            }
                            
                            // 更新位置
                            stormPositions[i] += stormVelocities[i] * params.speed;
                            stormPositions[i + 1] += stormVelocities[i + 1] * params.speed;
                            stormPositions[i + 2] += stormVelocities[i + 2] * params.speed;
                            
                            // 边界检测
                            if (Math.abs(stormPositions[i]) > 30) {
                                stormPositions[i] = baseStormPositions[i];
                                stormVelocities[i] = (Math.random() - 0.5) * 0.1;
                            }
                            if (Math.abs(stormPositions[i + 1]) > 20) {
                                stormPositions[i + 1] = baseStormPositions[i + 1];
                                stormVelocities[i + 1] = (Math.random() - 0.5) * 0.1;
                            }
                            if (Math.abs(stormPositions[i + 2]) > 30) {
                                stormPositions[i + 2] = baseStormPositions[i + 2];
                                stormVelocities[i + 2] = (Math.random() - 0.5) * 0.1;
                            }
                        }
                        
                        obj.geometry.attributes.position.needsUpdate = true;
                        break;
                        
                    case 'vortex':
                        // 漩涡旋转
                        obj.rotation.z += deltaTime * params.speed * obj.userData.rotationSpeed;
                        break;
                }
            });
        }
        
        // 更新效果描述
        function updateEffectDescription(title, description) {
            const descElement = document.getElementById('effectDescription');
            descElement.innerHTML = `<strong>${title}</strong><br>${description}`;
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 特效按钮
            document.querySelectorAll('.effect-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const effect = e.target.dataset.effect;
                    
                    // 更新按钮状态
                    document.querySelectorAll('.effect-button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // 切换特效
                    switch (effect) {
                        case 'resonance':
                            createResonanceEffect();
                            break;
                        case 'triangle':
                            createTriangleEffect();
                            break;
                        case 'square':
                            createSquareEffect();
                            break;
                        case 'spiral':
                            createSpiralEffect();
                            break;
                        case 'particles':
                            createParticleStormEffect();
                            break;
                    }
                });
            });
            
            // 参数滑块
            const intensitySlider = document.getElementById('intensity');
            intensitySlider.addEventListener('input', (e) => {
                params.intensity = e.target.value / 100;
                document.getElementById('intensityValue').textContent = e.target.value;
            });
            
            const speedSlider = document.getElementById('speed');
            speedSlider.addEventListener('input', (e) => {
                params.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value;
            });
            
            const scaleSlider = document.getElementById('scale');
            scaleSlider.addEventListener('input', (e) => {
                params.scale = parseFloat(e.target.value);
                document.getElementById('scaleValue').textContent = e.target.value;
            });
            
            // 后处理控制
            const bloomCheckbox = document.getElementById('bloom');
            bloomCheckbox.addEventListener('change', (e) => {
                params.bloom = e.target.checked;
                if (window.bloomPass) {
                    window.bloomPass.enabled = params.bloom;
                }
            });
            
            const bloomIntensitySlider = document.getElementById('bloomIntensity');
            bloomIntensitySlider.addEventListener('input', (e) => {
                params.bloomIntensity = parseFloat(e.target.value);
                if (window.bloomPass) {
                    window.bloomPass.strength = params.bloomIntensity;
                }
            });
            
            // 重置相机按钮
            document.getElementById('resetCamera').addEventListener('click', () => {
                camera.position.set(0, 10, 30);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 动画循环
        let lastTime = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            controls.update();
            updateEffects(deltaTime);
            
            // 使用后处理或普通渲染
            if (params.bloom && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        
        // 初始化
        init();
    </script>
</body>
</html>