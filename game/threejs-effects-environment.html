<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>环境特效演示 - 几何境域：形态之战</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes pulse-glow {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .float-animation {
            animation: float 3s ease-in-out infinite;
        }
        
        .pulse-glow {
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        .effect-card {
            transition: all 0.3s ease;
        }
        
        .effect-card:hover {
            transform: translateY(-5px);
        }
        
        #canvas-container {
            position: relative;
            background: radial-gradient(ellipse at center, #0a1628 0%, #000511 100%);
        }
        
        .control-panel {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .terrain-button {
            transition: all 0.2s ease;
        }
        
        .terrain-button:hover {
            transform: scale(1.05);
        }
        
        .terrain-button.active {
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            border-color: #60a5fa;
        }
        
        .weather-indicator {
            transition: all 0.3s ease;
        }
        
        .weather-indicator.active {
            transform: scale(1.2);
            filter: brightness(1.5);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <!-- Navigation -->
    <nav class="fixed top-0 w-full bg-gray-800/90 backdrop-blur-md z-50 border-b border-gray-700">
        <div class="container mx-auto px-4">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center space-x-3">
                    <a href="threejs-effects-hub.html" class="flex items-center space-x-2 hover:text-blue-400 transition">
                        <i class="fas fa-arrow-left text-gray-400"></i>
                    </a>
                    <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-cyan-600 rounded-full flex items-center justify-center">
                        <i class="fas fa-cloud text-white"></i>
                    </div>
                    <span class="text-xl font-bold bg-gradient-to-r from-blue-400 to-cyan-600 bg-clip-text text-transparent">
                        环境特效演示
                    </span>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="fullscreen-btn" class="p-2 rounded-lg hover:bg-gray-700 transition">
                        <i class="fas fa-expand"></i>
                    </button>
                    <button id="reset-btn" class="p-2 rounded-lg hover:bg-gray-700 transition">
                        <i class="fas fa-redo"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="pt-20">
        <!-- Control Panel -->
        <div class="fixed left-4 top-24 w-80 control-panel rounded-lg p-4 z-40">
            <h3 class="text-lg font-bold mb-4 text-blue-400">环境控制面板</h3>
            
            <!-- Terrain Type -->
            <div class="mb-6">
                <h4 class="text-sm font-semibold mb-3 text-gray-300">地形类型</h4>
                <div class="grid grid-cols-2 gap-2">
                    <button class="terrain-button px-3 py-2 bg-gray-700 rounded-lg text-sm hover:bg-gray-600 active" data-terrain="plains">
                        <i class="fas fa-mountain mr-1"></i> 平原
                    </button>
                    <button class="terrain-button px-3 py-2 bg-gray-700 rounded-lg text-sm hover:bg-gray-600" data-terrain="forest">
                        <i class="fas fa-tree mr-1"></i> 森林
                    </button>
                    <button class="terrain-button px-3 py-2 bg-gray-700 rounded-lg text-sm hover:bg-gray-600" data-terrain="desert">
                        <i class="fas fa-sun mr-1"></i> 沙漠
                    </button>
                    <button class="terrain-button px-3 py-2 bg-gray-700 rounded-lg text-sm hover:bg-gray-600" data-terrain="arctic">
                        <i class="fas fa-snowflake mr-1"></i> 极地
                    </button>
                </div>
            </div>

            <!-- Weather System -->
            <div class="mb-6">
                <h4 class="text-sm font-semibold mb-3 text-gray-300">天气系统</h4>
                <div class="flex justify-between mb-2">
                    <button class="weather-indicator p-2 bg-gray-700 rounded-lg hover:bg-gray-600" data-weather="clear">
                        <i class="fas fa-sun text-yellow-400"></i>
                    </button>
                    <button class="weather-indicator p-2 bg-gray-700 rounded-lg hover:bg-gray-600" data-weather="rain">
                        <i class="fas fa-cloud-rain text-blue-400"></i>
                    </button>
                    <button class="weather-indicator p-2 bg-gray-700 rounded-lg hover:bg-gray-600" data-weather="snow">
                        <i class="fas fa-snowflake text-cyan-400"></i>
                    </button>
                    <button class="weather-indicator p-2 bg-gray-700 rounded-lg hover:bg-gray-600 active" data-weather="storm">
                        <i class="fas fa-bolt text-purple-400"></i>
                    </button>
                </div>
            </div>

            <!-- Time of Day -->
            <div class="mb-6">
                <h4 class="text-sm font-semibold mb-3 text-gray-300">时间控制</h4>
                <input type="range" id="time-slider" min="0" max="24" step="0.1" value="12" class="w-full">
                <div class="flex justify-between text-xs mt-1 text-gray-400">
                    <span>00:00</span>
                    <span id="current-time">12:00</span>
                    <span>24:00</span>
                </div>
            </div>

            <!-- Dynamic Effects -->
            <div class="mb-6">
                <h4 class="text-sm font-semibold mb-3 text-gray-300">动态效果</h4>
                <div class="space-y-2">
                    <label class="flex items-center">
                        <input type="checkbox" id="wind-effect" checked class="mr-2">
                        <span class="text-sm">风吹草动</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="water-ripple" checked class="mr-2">
                        <span class="text-sm">水面波纹</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="particle-flow" checked class="mr-2">
                        <span class="text-sm">粒子流动</span>
                    </label>
                    <label class="flex items-center">
                        <input type="checkbox" id="ambient-life" class="mr-2">
                        <span class="text-sm">环境生物</span>
                    </label>
                </div>
            </div>

            <!-- Performance Stats -->
            <div class="mt-6 p-3 bg-gray-800 rounded-lg">
                <div class="text-xs space-y-1">
                    <div class="flex justify-between">
                        <span class="text-gray-400">FPS:</span>
                        <span id="fps-counter">60</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">粒子数:</span>
                        <span id="particle-count">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">环境对象:</span>
                        <span id="object-count">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3D Canvas Container -->
        <div id="canvas-container" class="fixed inset-0 pt-16">
            <!-- Three.js canvas will be inserted here -->
        </div>

        <!-- Info Panel -->
        <div class="fixed right-4 top-24 w-72 bg-gray-800/90 backdrop-blur-md rounded-lg p-4">
            <h3 class="text-lg font-bold mb-4 text-cyan-400">环境信息</h3>
            <div class="space-y-3 text-sm">
                <div>
                    <span class="text-gray-400">当前地形:</span>
                    <span id="current-terrain" class="ml-2 text-white">平原</span>
                </div>
                <div>
                    <span class="text-gray-400">天气状况:</span>
                    <span id="current-weather" class="ml-2 text-white">雷暴</span>
                </div>
                <div>
                    <span class="text-gray-400">环境亮度:</span>
                    <div class="mt-1 w-full bg-gray-700 rounded-full h-2">
                        <div id="brightness-bar" class="bg-gradient-to-r from-gray-600 to-yellow-400 h-2 rounded-full" style="width: 70%"></div>
                    </div>
                </div>
                <div>
                    <span class="text-gray-400">特效强度:</span>
                    <div class="mt-1 w-full bg-gray-700 rounded-full h-2">
                        <div id="effect-intensity-bar" class="bg-gradient-to-r from-blue-600 to-cyan-400 h-2 rounded-full" style="width: 85%"></div>
                    </div>
                </div>
            </div>

            <div class="mt-6 p-3 bg-gray-900 rounded-lg">
                <h4 class="font-semibold mb-2 text-gray-300">操作提示</h4>
                <ul class="text-xs space-y-1 text-gray-400">
                    <li><i class="fas fa-mouse mr-1"></i> 左键拖动旋转视角</li>
                    <li><i class="fas fa-search-plus mr-1"></i> 滚轮缩放场景</li>
                    <li><i class="fas fa-hand-paper mr-1"></i> 右键拖动平移</li>
                    <li><i class="fas fa-keyboard mr-1"></i> 空格键暂停/播放</li>
                </ul>
            </div>
        </div>

        <!-- Race Influence Panel -->
        <div class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800/90 backdrop-blur-md rounded-full px-6 py-3">
            <div class="flex items-center space-x-6">
                <div class="text-center">
                    <div class="w-12 h-12 bg-blue-500/20 rounded-full flex items-center justify-center mb-1">
                        <i class="fas fa-circle text-blue-400"></i>
                    </div>
                    <span class="text-xs text-gray-400">圆环族</span>
                </div>
                <div class="text-center">
                    <div class="w-12 h-12 bg-red-500/20 rounded-full flex items-center justify-center mb-1">
                        <i class="fas fa-play text-red-400 transform rotate-90"></i>
                    </div>
                    <span class="text-xs text-gray-400">三角议会</span>
                </div>
                <div class="text-center">
                    <div class="w-12 h-12 bg-green-500/20 rounded-full flex items-center justify-center mb-1">
                        <i class="fas fa-square text-green-400"></i>
                    </div>
                    <span class="text-xs text-gray-400">方碑盟约</span>
                </div>
                <div class="text-center">
                    <div class="w-12 h-12 bg-purple-500/20 rounded-full flex items-center justify-center mb-1">
                        <i class="fas fa-hurricane text-purple-400"></i>
                    </div>
                    <span class="text-xs text-gray-400">螺旋之子</span>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Three.js Scene Setup
        let scene, camera, renderer, composer;
        let controls;
        let environment = {
            terrain: 'plains',
            weather: 'storm',
            time: 12,
            windSpeed: 1.0,
            windDirection: 0,
            particles: [],
            effects: {
                wind: true,
                water: true,
                particles: true,
                life: false
            }
        };

        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a1628, 10, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 15, 30);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            // Post-processing
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.5,
                0.4,
                0.85
            );
            composer.addPass(bloomPass);

            // Lighting
            setupLighting();

            // Create environment
            createEnvironment();

            // Event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 50, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);

            // Store references
            environment.sunLight = sunLight;
            environment.ambientLight = ambientLight;
        }

        function createEnvironment() {
            // Clear existing objects
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            environment.particles = [];

            // Re-add lights
            setupLighting();

            // Create terrain based on type
            switch(environment.terrain) {
                case 'plains':
                    createPlains();
                    break;
                case 'forest':
                    createForest();
                    break;
                case 'desert':
                    createDesert();
                    break;
                case 'arctic':
                    createArctic();
                    break;
            }

            // Create weather effects
            createWeatherEffects();

            // Create water body
            if (environment.effects.water) {
                createWater();
            }
        }

        function createPlains() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a5f3a,
                wireframe: false
            });
            
            // Add terrain variation
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 2;
            }
            groundGeometry.computeVertexNormals();
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grass patches
            if (environment.effects.wind) {
                createGrassField();
            }

            // Update info
            document.getElementById('current-terrain').textContent = '平原';
        }

        function createGrassField() {
            const grassGroup = new THREE.Group();
            
            for (let i = 0; i < 500; i++) {
                const height = 0.5 + Math.random() * 1.5;
                const grassGeometry = new THREE.ConeGeometry(0.1, height, 4);
                const grassMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.25, 0.6, 0.3 + Math.random() * 0.2)
                });
                
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.position.set(
                    (Math.random() - 0.5) * 80,
                    height / 2,
                    (Math.random() - 0.5) * 80
                );
                grass.rotation.y = Math.random() * Math.PI * 2;
                grass.userData.originalRotation = grass.rotation.y;
                grass.userData.swaySpeed = 0.5 + Math.random() * 1.5;
                grass.userData.swayAmount = 0.1 + Math.random() * 0.2;
                
                grassGroup.add(grass);
            }
            
            scene.add(grassGroup);
            environment.grassField = grassGroup;
        }

        function createForest() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 30, 30);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2d4a2b });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Trees
            for (let i = 0; i < 50; i++) {
                createTree(
                    (Math.random() - 0.5) * 80,
                    (Math.random() - 0.5) * 80
                );
            }

            document.getElementById('current-terrain').textContent = '森林';
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            // Foliage
            const foliageGeometry = new THREE.ConeGeometry(3, 6, 8);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 6;
            foliage.castShadow = true;
            treeGroup.add(foliage);
            
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
        }

        function createDesert() {
            // Sandy ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 40, 40);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xc2b280 });
            
            // Add dunes
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.05) * Math.cos(vertices[i + 1] * 0.05) * 5;
            }
            groundGeometry.computeVertexNormals();
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Cacti
            for (let i = 0; i < 20; i++) {
                createCactus(
                    (Math.random() - 0.5) * 80,
                    (Math.random() - 0.5) * 80
                );
            }

            document.getElementById('current-terrain').textContent = '沙漠';
        }

        function createCactus(x, z) {
            const cactusGroup = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.7, 3, 8);
            const cactusMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5a2d });
            const body = new THREE.Mesh(bodyGeometry, cactusMaterial);
            body.position.y = 1.5;
            body.castShadow = true;
            cactusGroup.add(body);
            
            // Arms
            if (Math.random() > 0.5) {
                const armGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 6);
                const arm = new THREE.Mesh(armGeometry, cactusMaterial);
                arm.position.set(1, 2, 0);
                arm.rotation.z = Math.PI / 4;
                arm.castShadow = true;
                cactusGroup.add(arm);
            }
            
            cactusGroup.position.set(x, 0, z);
            scene.add(cactusGroup);
        }

        function createArctic() {
            // Snow ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 30, 30);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xe0e0e0,
                roughness: 0.8
            });
            
            // Add snow drifts
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.sin(vertices[i + 1] * 0.1) * 3;
            }
            groundGeometry.computeVertexNormals();
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Ice formations
            for (let i = 0; i < 15; i++) {
                createIceFormation(
                    (Math.random() - 0.5) * 80,
                    (Math.random() - 0.5) * 80
                );
            }

            document.getElementById('current-terrain').textContent = '极地';
        }

        function createIceFormation(x, z) {
            const iceGeometry = new THREE.ConeGeometry(
                1 + Math.random() * 2,
                3 + Math.random() * 4,
                6
            );
            const iceMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xb3e5fc,
                metalness: 0.1,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8,
                clearcoat: 1
            });
            
            const ice = new THREE.Mesh(iceGeometry, iceMaterial);
            ice.position.set(x, iceGeometry.parameters.height / 2, z);
            ice.castShadow = true;
            ice.receiveShadow = true;
            scene.add(ice);
        }

        function createWater() {
            const waterGeometry = new THREE.PlaneGeometry(40, 40, 32, 32);
            const waterMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x006994,
                metalness: 0.1,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.1;
            
            scene.add(water);
            environment.water = water;
        }

        function createWeatherEffects() {
            // Clear existing weather particles
            environment.particles.forEach(p => scene.remove(p));
            environment.particles = [];

            switch(environment.weather) {
                case 'rain':
                    createRain();
                    break;
                case 'snow':
                    createSnow();
                    break;
                case 'storm':
                    createStorm();
                    break;
                case 'clear':
                    // No particles for clear weather
                    break;
            }

            // Update weather display
            const weatherNames = {
                'clear': '晴天',
                'rain': '雨天',
                'snow': '雪天',
                'storm': '雷暴'
            };
            document.getElementById('current-weather').textContent = weatherNames[environment.weather];
        }

        function createRain() {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = Math.random() * 50 + 10;
                positions[i + 2] = (Math.random() - 0.5) * 100;
                
                velocities[i] = (Math.random() - 0.5) * 0.1;
                velocities[i + 1] = -5 - Math.random() * 5;
                velocities[i + 2] = (Math.random() - 0.5) * 0.1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x6495ed,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const rain = new THREE.Points(geometry, material);
            scene.add(rain);
            environment.particles.push(rain);
        }

        function createSnow() {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = Math.random() * 50 + 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = -0.5 - Math.random() * 1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                sizes[i] = Math.random() * 0.3 + 0.1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            const snow = new THREE.Points(geometry, material);
            scene.add(snow);
            environment.particles.push(snow);
        }

        function createStorm() {
            // Rain
            createRain();
            
            // Lightning effect
            const lightningGroup = new THREE.Group();
            environment.lightning = lightningGroup;
            scene.add(lightningGroup);
        }

        function updateEnvironment(deltaTime) {
            // Update time of day
            updateTimeOfDay();

            // Update wind effects
            if (environment.effects.wind && environment.grassField) {
                updateWindEffects(deltaTime);
            }

            // Update water ripples
            if (environment.effects.water && environment.water) {
                updateWaterRipples(deltaTime);
            }

            // Update weather particles
            updateWeatherParticles(deltaTime);

            // Update lightning
            if (environment.weather === 'storm' && environment.lightning) {
                updateLightning(deltaTime);
            }

            // Update performance stats
            updatePerformanceStats();
        }

        function updateTimeOfDay() {
            const time = parseFloat(document.getElementById('time-slider').value);
            const hours = Math.floor(time);
            const minutes = Math.floor((time - hours) * 60);
            document.getElementById('current-time').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

            // Update lighting based on time
            const sunAngle = (time / 24) * Math.PI * 2 - Math.PI / 2;
            const sunHeight = Math.sin(sunAngle) * 50;
            const sunDistance = Math.cos(sunAngle) * 50;
            
            if (environment.sunLight) {
                environment.sunLight.position.set(sunDistance, Math.max(sunHeight, 5), 0);
                environment.sunLight.intensity = Math.max(0.1, Math.sin(sunAngle));
            }

            // Update ambient light
            const ambientIntensity = 0.2 + Math.max(0, Math.sin(sunAngle)) * 0.3;
            if (environment.ambientLight) {
                environment.ambientLight.intensity = ambientIntensity;
            }

            // Update brightness bar
            const brightness = Math.max(10, Math.sin(sunAngle) * 100);
            document.getElementById('brightness-bar').style.width = `${brightness}%`;
        }

        function updateWindEffects(deltaTime) {
            const time = Date.now() * 0.001;
            environment.grassField.children.forEach(grass => {
                if (grass.userData.swaySpeed) {
                    const sway = Math.sin(time * grass.userData.swaySpeed) * grass.userData.swayAmount;
                    grass.rotation.z = grass.userData.originalRotation + sway * environment.windSpeed;
                }
            });
        }

        function updateWaterRipples(deltaTime) {
            if (!environment.water) return;
            
            const time = Date.now() * 0.001;
            const positions = environment.water.geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                positions[i + 2] = Math.sin(x * 0.2 + time) * Math.cos(y * 0.2 + time) * 0.2;
            }
            
            environment.water.geometry.attributes.position.needsUpdate = true;
            environment.water.geometry.computeVertexNormals();
        }

        function updateWeatherParticles(deltaTime) {
            environment.particles.forEach(particleSystem => {
                const positions = particleSystem.geometry.attributes.position.array;
                const velocities = particleSystem.geometry.attributes.velocity.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i] * deltaTime * environment.windSpeed;
                    positions[i + 1] += velocities[i + 1] * deltaTime;
                    positions[i + 2] += velocities[i + 2] * deltaTime;
                    
                    // Reset particle if it goes below ground
                    if (positions[i + 1] < 0) {
                        positions[i] = (Math.random() - 0.5) * 100;
                        positions[i + 1] = 30 + Math.random() * 20;
                        positions[i + 2] = (Math.random() - 0.5) * 100;
                    }
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
            });
        }

        function updateLightning(deltaTime) {
            // Random lightning strikes
            if (Math.random() < 0.001) {
                // Create lightning bolt
                const lightningGeometry = new THREE.BufferGeometry();
                const points = [];
                let x = (Math.random() - 0.5) * 100;
                let y = 30;
                let z = (Math.random() - 0.5) * 100;
                
                points.push(new THREE.Vector3(x, y, z));
                
                for (let i = 0; i < 10; i++) {
                    x += (Math.random() - 0.5) * 5;
                    y -= 3;
                    z += (Math.random() - 0.5) * 5;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                lightningGeometry.setFromPoints(points);
                
                const lightningMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    linewidth: 2,
                    transparent: true,
                    opacity: 1
                });
                
                const lightning = new THREE.Line(lightningGeometry, lightningMaterial);
                environment.lightning.add(lightning);
                
                // Flash effect
                if (environment.sunLight) {
                    environment.sunLight.intensity = 2;
                    setTimeout(() => {
                        environment.sunLight.intensity = 0.5;
                    }, 100);
                }
                
                // Remove lightning after flash
                setTimeout(() => {
                    environment.lightning.remove(lightning);
                }, 200);
            }
        }

        function updatePerformanceStats() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                
                document.getElementById('fps-counter').textContent = fps;
            }
            
            // Count particles
            let particleCount = 0;
            environment.particles.forEach(p => {
                particleCount += p.geometry.attributes.position.count;
            });
            document.getElementById('particle-count').textContent = particleCount;
            
            // Count objects
            document.getElementById('object-count').textContent = scene.children.length;
        }

        function setupEventListeners() {
            // Terrain buttons
            document.querySelectorAll('.terrain-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.terrain-button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    environment.terrain = btn.dataset.terrain;
                    createEnvironment();
                });
            });

            // Weather buttons
            document.querySelectorAll('.weather-indicator').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.weather-indicator').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    environment.weather = btn.dataset.weather;
                    createWeatherEffects();
                });
            });

            // Time slider
            document.getElementById('time-slider').addEventListener('input', updateTimeOfDay);

            // Effect checkboxes
            document.getElementById('wind-effect').addEventListener('change', (e) => {
                environment.effects.wind = e.target.checked;
                if (e.target.checked && environment.terrain === 'plains') {
                    createGrassField();
                }
            });

            document.getElementById('water-ripple').addEventListener('change', (e) => {
                environment.effects.water = e.target.checked;
                if (e.target.checked && !environment.water) {
                    createWater();
                } else if (!e.target.checked && environment.water) {
                    scene.remove(environment.water);
                    environment.water = null;
                }
            });

            document.getElementById('particle-flow').addEventListener('change', (e) => {
                environment.effects.particles = e.target.checked;
            });

            document.getElementById('ambient-life').addEventListener('change', (e) => {
                environment.effects.life = e.target.checked;
                // TODO: Add ambient life (birds, butterflies, etc.)
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    controls.autoRotate = !controls.autoRotate;
                }
            });

            // Fullscreen
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            });

            // Reset
            document.getElementById('reset-btn').addEventListener('click', () => {
                // Reset camera
                camera.position.set(0, 15, 30);
                camera.lookAt(0, 0, 0);
                controls.reset();
                
                // Reset time
                document.getElementById('time-slider').value = 12;
                updateTimeOfDay();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        let animationLastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - animationLastTime) / 1000;
            animationLastTime = currentTime;
            
            controls.update();
            updateEnvironment(deltaTime);
            composer.render();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>