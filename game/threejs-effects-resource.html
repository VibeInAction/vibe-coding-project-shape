<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>资源特效演示 - 几何境域：形态之战</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0f172a;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            z-index: 10;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .effect-button {
            @apply w-full p-3 mb-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition-all duration-200 text-white font-medium;
        }
        
        .effect-button.active {
            @apply bg-green-600 hover:bg-green-500;
        }
        
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 15px;
            z-index: 10;
            max-width: 300px;
        }
        
        .control-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.5);
            border-radius: 3px;
        }
        
        .control-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.7);
        }
        
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
        
        .resource-counter {
            @apply bg-gray-800 rounded-lg p-3 mb-3;
        }
        
        .resource-value {
            @apply text-2xl font-bold text-green-400;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <!-- 返回链接 -->
    <a href="threejs-effects-hub.html" class="back-link bg-gray-800/90 backdrop-blur-md text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition flex items-center space-x-2">
        <i class="fas fa-arrow-left"></i>
        <span>返回特效中心</span>
    </a>
    
    <!-- 控制面板 -->
    <div class="control-panel">
        <h2 class="text-xl font-bold mb-4 text-white">资源特效控制</h2>
        
        <!-- 资源显示 -->
        <div class="resource-counter">
            <div class="flex justify-between items-center mb-2">
                <span class="text-gray-300">形魄能量</span>
                <span id="resourceCount" class="resource-value">0</span>
            </div>
            <div class="w-full bg-gray-700 rounded-full h-2">
                <div id="resourceProgress" class="bg-green-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- 特效选择 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">资源采集特效</h3>
            <button class="effect-button active" data-effect="normal-collection">形魄能量采集</button>
            <button class="effect-button" data-effect="pure-collection">纯净形魄采集</button>
        </div>
        
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">建筑特效</h3>
            <button class="effect-button" data-effect="building-construct">建筑建造</button>
            <button class="effect-button" data-effect="building-upgrade">建筑升级</button>
        </div>
        
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">存储特效</h3>
            <button class="effect-button" data-effect="storage-fill">能量充填</button>
            <button class="effect-button" data-effect="storage-overflow">存储溢出</button>
        </div>
        
        <!-- 参数控制 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">特效参数</h3>
            
            <div class="mb-3">
                <label class="text-xs text-gray-400">采集速度</label>
                <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1" 
                       class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="speedValue" class="text-xs text-gray-400">1.0x</span>
            </div>
            
            <div class="mb-3">
                <label class="text-xs text-gray-400">特效密度</label>
                <input type="range" id="density" min="0.5" max="2" step="0.1" value="1" 
                       class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <span id="densityValue" class="text-xs text-gray-400">1.0</span>
            </div>
        </div>
        
        <!-- 后处理效果 -->
        <div class="mb-4">
            <h3 class="text-sm font-semibold text-gray-300 mb-2">后处理效果</h3>
            <label class="flex items-center text-sm text-gray-300 mb-2">
                <input type="checkbox" id="bloom" checked class="mr-2">
                辉光效果
            </label>
        </div>
        
        <!-- 相机控制 -->
        <div>
            <button id="resetCamera" class="effect-button">重置视角</button>
        </div>
    </div>
    
    <!-- 信息面板 -->
    <div class="info-panel">
        <h3 class="text-lg font-bold text-white mb-2">当前特效</h3>
        <p id="effectDescription" class="text-sm text-gray-300">
            形魄能量采集 - 采集器周围的光环效果
        </p>
        <div class="mt-3 text-xs text-gray-400">
            <p>• 鼠标左键：旋转视角</p>
            <p>• 鼠标右键：平移视角</p>
            <p>• 滚轮：缩放</p>
        </div>
    </div>
    
    <script>
        // 全局变量
        let scene, camera, renderer, composer;
        let controls;
        let currentEffect = null;
        let effectObjects = [];
        let animationId = null;
        let resourceCount = 0;
        
        // 特效参数
        const params = {
            speed: 1.0,
            density: 1.0,
            bloom: true
        };
        
        // 初始化Three.js场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0f172a, 10, 100);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 15, 25);
            camera.lookAt(0, 0, 0);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 100;
            controls.minDistance = 5;
            
            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // 添加点光源
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // 创建后处理
            setupPostProcessing();
            
            // 添加网格地板
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // 初始化特效
            createNormalCollectionEffect();
            
            // 设置事件监听
            setupEventListeners();
            
            // 开始动画循环
            animate();
        }
        
        // 设置后处理
        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.4, // radius
                0.85 // threshold
            );
            composer.addPass(bloomPass);
            
            // 保存引用以便调整
            window.bloomPass = bloomPass;
        }
        
        // 清理当前特效
        function clearCurrentEffect() {
            effectObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                if (obj.children) {
                    obj.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            });
            effectObjects = [];
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // 创建普通形魄能量采集效果
        function createNormalCollectionEffect() {
            clearCurrentEffect();
            
            // 创建采集器
            const collectorGeometry = new THREE.CylinderGeometry(2, 3, 1, 6);
            const collectorMaterial = new THREE.MeshBasicMaterial({
                color: 0x10b981,
                transparent: true,
                opacity: 0.6,
                wireframe: true
            });
            
            const collector = new THREE.Mesh(collectorGeometry, collectorMaterial);
            collector.position.y = 0.5;
            collector.userData = {
                type: 'collector',
                rotation: 0
            };
            
            scene.add(collector);
            effectObjects.push(collector);
            
            // 创建光环效果
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.RingGeometry(3 + i * 0.5, 3.5 + i * 0.5, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x10b981,
                    transparent: true,
                    opacity: 0.3 - i * 0.1,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.1;
                ring.userData = {
                    type: 'collection-ring',
                    index: i,
                    phase: i * Math.PI / 3
                };
                
                scene.add(ring);
                effectObjects.push(ring);
            }
            
            // 创建能量粒子
            const energyParticles = createEnergyParticles(100, 0x10b981);
            scene.add(energyParticles);
            effectObjects.push(energyParticles);
            
            updateEffectDescription('形魄能量采集', '采集器周围的光环效果，资源流动的粒子');
            
            animateNormalCollection();
        }
        
        // 创建能量粒子
        function createEnergyParticles(count, color) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const targets = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                // 随机初始位置
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.random() * 5;
                const height = Math.random() * 3;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 目标位置（向采集器聚集）
                targets[i * 3] = (Math.random() - 0.5) * 4;
                targets[i * 3 + 1] = 0.5;
                targets[i * 3 + 2] = (Math.random() - 0.5) * 4;
                
                // 颜色
                const colorObj = new THREE.Color(color);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'energy-particles',
                targets: targets,
                speeds: new Float32Array(count).fill(0.01 + Math.random() * 0.02),
                collected: new Float32Array(count).fill(0)
            };
            
            return particles;
        }
        
        // 普通采集动画
        function animateNormalCollection() {
            const collector = effectObjects.find(obj => obj.userData.type === 'collector');
            const rings = effectObjects.filter(obj => obj.userData.type === 'collection-ring');
            const particles = effectObjects.find(obj => obj.userData.type === 'energy-particles');
            
            if (!collector || !rings.length || !particles) return;
            
            // 采集器旋转
            collector.userData.rotation += 0.01 * params.speed;
            collector.rotation.y = collector.userData.rotation;
            
            // 光环脉动
            rings.forEach(ring => {
                ring.userData.phase += 0.02 * params.speed;
                const scale = 1 + Math.sin(ring.userData.phase) * 0.2 * params.density;
                ring.scale.set(scale, scale, scale);
            });
            
            // 粒子运动
            const positions = particles.geometry.attributes.position.array;
            const targets = particles.userData.targets;
            const speeds = particles.userData.speeds;
            const collected = particles.userData.collected;
            
            let collectedCount = 0;
            
            for (let i = 0; i < positions.length; i += 3) {
                if (collected[i / 3] < 1) {
                    // 向目标移动
                    const dx = targets[i] - positions[i];
                    const dy = targets[i + 1] - positions[i + 1];
                    const dz = targets[i + 2] - positions[i + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance > 0.5) {
                        positions[i] += dx * speeds[i / 3] * params.speed;
                        positions[i + 1] += dy * speeds[i / 3] * params.speed;
                        positions[i + 2] += dz * speeds[i / 3] * params.speed;
                    } else {
                        collected[i / 3] = 1;
                        collectedCount++;
                    }
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // 更新资源计数
            if (collectedCount > 0) {
                resourceCount += collectedCount * 0.1 * params.speed;
                updateResourceDisplay();
                
                // 重置粒子
                for (let i = 0; i < collected.length; i++) {
                    if (collected[i] > 0) {
                        collected[i] = 0;
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 5 + Math.random() * 5;
                        positions[i * 3] = Math.cos(angle) * radius;
                        positions[i * 3 + 1] = Math.random() * 3;
                        positions[i * 3 + 2] = Math.sin(angle) * radius;
                    }
                }
            }
            
            animationId = requestAnimationFrame(animateNormalCollection);
        }
        
        // 更新资源显示
        function updateResourceDisplay() {
            const displayCount = Math.floor(resourceCount);
            document.getElementById('resourceCount').textContent = displayCount;
            
            const progress = Math.min((resourceCount % 100) / 100 * 100, 100);
            document.getElementById('resourceProgress').style.width = progress + '%';
        }
        
        // 创建纯净形魄采集效果
        function createPureCollectionEffect() {
            clearCurrentEffect();
            
            // 创建高级采集器
            const collectorGeometry = new THREE.OctahedronGeometry(3, 0);
            const collectorMaterial = new THREE.MeshBasicMaterial({
                color: 0xfbbf24,
                transparent: true,
                opacity: 0.7,
                wireframe: true
            });
            
            const collector = new THREE.Mesh(collectorGeometry, collectorMaterial);
            collector.position.y = 2;
            collector.userData = {
                type: 'pure-collector',
                rotation: { x: 0, y: 0, z: 0 }
            };
            
            scene.add(collector);
            effectObjects.push(collector);
            
            // 创建多层光环
            for (let i = 0; i < 5; i++) {
                const ringGeometry = new THREE.TorusGeometry(4 + i * 0.8, 0.2, 8, 32);
                const hue = (i * 72) / 360; // 彩虹色
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 0.8, 0.5),
                    transparent: true,
                    opacity: 0.6
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.5;
                ring.userData = {
                    type: 'pure-ring',
                    index: i,
                    rotationSpeed: 0.02 + i * 0.01
                };
                
                scene.add(ring);
                effectObjects.push(ring);
            }
            
            // 创建彩色粒子
            const rainbowParticles = createRainbowParticles(150);
            scene.add(rainbowParticles);
            effectObjects.push(rainbowParticles);
            
            // 创建庆祝效果
            const celebration = createCelebrationEffect();
            scene.add(celebration);
            effectObjects.push(celebration);
            
            updateEffectDescription('纯净形魄采集', '更亮更强的光环效果，稀有的彩色粒子');
            
            animatePureCollection();
        }
        
        // 创建彩虹粒子
        function createRainbowParticles(count) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const targets = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                // 随机初始位置
                const angle = Math.random() * Math.PI * 2;
                const radius = 8 + Math.random() * 7;
                const height = Math.random() * 5;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 目标位置
                targets[i * 3] = (Math.random() - 0.5) * 2;
                targets[i * 3 + 1] = 2;
                targets[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                // 彩虹颜色
                const hue = (i / count) * 360 / 360;
                const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'rainbow-particles',
                targets: targets,
                speeds: new Float32Array(count).fill(0.015 + Math.random() * 0.015),
                collected: new Float32Array(count).fill(0),
                colors: colors
            };
            
            return particles;
        }
        
        // 创建庆祝效果
        function createCelebrationEffect() {
            const group = new THREE.Group();
            
            // 创建上升的星星
            for (let i = 0; i < 20; i++) {
                const starGeometry = new THREE.OctahedronGeometry(0.2, 0);
                const starMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.5),
                    transparent: true,
                    opacity: 0.8
                });
                
                const star = new THREE.Mesh(starGeometry, starMaterial);
                star.position.set(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 10
                );
                star.userData = {
                    type: 'celebration-star',
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.05,
                        0.05 + Math.random() * 0.05,
                        (Math.random() - 0.5) * 0.05
                    ),
                    life: 1.0
                };
                
                group.add(star);
            }
            
            group.userData = {
                type: 'celebration'
            };
            
            return group;
        }
        
        // 纯净采集动画
        function animatePureCollection() {
            const collector = effectObjects.find(obj => obj.userData.type === 'pure-collector');
            const rings = effectObjects.filter(obj => obj.userData.type === 'pure-ring');
            const particles = effectObjects.find(obj => obj.userData.type === 'rainbow-particles');
            const celebration = effectObjects.find(obj => obj.userData.type === 'celebration');
            
            if (!collector || !rings.length || !particles || !celebration) return;
            
            // 采集器旋转
            collector.userData.rotation.x += 0.01 * params.speed;
            collector.userData.rotation.y += 0.02 * params.speed;
            collector.userData.rotation.z += 0.005 * params.speed;
            collector.rotation.set(
                collector.userData.rotation.x,
                collector.userData.rotation.y,
                collector.userData.rotation.z
            );
            
            // 环形旋转
            rings.forEach((ring, index) => {
                ring.rotation.z += ring.userData.rotationSpeed * params.speed;
                ring.rotation.y += ring.userData.rotationSpeed * 0.5 * params.speed;
            });
            
            // 粒子运动
            const positions = particles.geometry.attributes.position.array;
            const targets = particles.userData.targets;
            const speeds = particles.userData.speeds;
            const collected = particles.userData.collected;
            
            let collectedCount = 0;
            
            for (let i = 0; i < positions.length; i += 3) {
                if (collected[i / 3] < 1) {
                    const dx = targets[i] - positions[i];
                    const dy = targets[i + 1] - positions[i + 1];
                    const dz = targets[i + 2] - positions[i + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance > 0.3) {
                        positions[i] += dx * speeds[i / 3] * params.speed;
                        positions[i + 1] += dy * speeds[i / 3] * params.speed;
                        positions[i + 2] += dz * speeds[i / 3] * params.speed;
                    } else {
                        collected[i / 3] = 1;
                        collectedCount++;
                    }
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // 更新资源（双倍）
            if (collectedCount > 0) {
                resourceCount += collectedCount * 0.2 * params.speed;
                updateResourceDisplay();
                
                // 触发庆祝效果
                if (resourceCount % 10 < 1) {
                    triggerCelebration(celebration);
                }
                
                // 重置粒子
                for (let i = 0; i < collected.length; i++) {
                    if (collected[i] > 0) {
                        collected[i] = 0;
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 8 + Math.random() * 7;
                        positions[i * 3] = Math.cos(angle) * radius;
                        positions[i * 3 + 1] = Math.random() * 5;
                        positions[i * 3 + 2] = Math.sin(angle) * radius;
                    }
                }
            }
            
            // 庆祝动画
            celebration.children.forEach(star => {
                if (star.userData.life > 0) {
                    star.position.add(star.userData.velocity.clone().multiplyScalar(params.speed));
                    star.userData.life -= 0.01 * params.speed;
                    star.material.opacity = star.userData.life;
                    star.rotation.x += 0.1 * params.speed;
                    star.rotation.y += 0.1 * params.speed;
                } else {
                    // 重置星星
                    star.position.set(
                        (Math.random() - 0.5) * 10,
                        0,
                        (Math.random() - 0.5) * 10
                    );
                    star.userData.life = 1.0;
                    star.material.opacity = 0.8;
                }
            });
            
            animationId = requestAnimationFrame(animatePureCollection);
        }
        
        // 触发庆祝效果
        function triggerCelebration(celebration) {
            celebration.children.forEach(star => {
                star.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    0.1 + Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                star.userData.life = 1.0;
            });
        }
        
        // 创建建筑建造效果
        function createBuildingConstructEffect() {
            clearCurrentEffect();
            
            // 创建地基
            const foundationGeometry = new THREE.BoxGeometry(6, 0.2, 6);
            const foundationMaterial = new THREE.MeshBasicMaterial({
                color: 0x6b7280,
                transparent: true,
                opacity: 0.8
            });
            
            const foundation = new THREE.Mesh(foundationGeometry, foundationMaterial);
            foundation.position.y = 0.1;
            scene.add(foundation);
            effectObjects.push(foundation);
            
            // 创建建筑框架
            const frameGroup = new THREE.Group();
            
            // 垂直柱子
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = Math.cos(angle) * 2.5;
                const z = Math.sin(angle) * 2.5;
                
                const pillarGeometry = new THREE.BoxGeometry(0.3, 5, 0.3);
                const pillarMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3b82f6,
                    transparent: true,
                    opacity: 0.6,
                    wireframe: true
                });
                
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(x, 2.5, z);
                pillar.userData = {
                    type: 'building-pillar',
                    growthPhase: 0
                };
                
                frameGroup.add(pillar);
                effectObjects.push(pillar);
            }
            
            // 横梁
            for (let i = 0; i < 2; i++) {
                const beamGeometry = new THREE.BoxGeometry(5.3, 0.3, 0.3);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3b82f6,
                    transparent: true,
                    opacity: 0.6,
                    wireframe: true
                });
                
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.y = 4 + i * 1;
                beam.userData = {
                    type: 'building-beam',
                    growthPhase: 0
                };
                
                frameGroup.add(beam);
                effectObjects.push(beam);
            }
            
            frameGroup.userData = {
                type: 'building-frame'
            };
            
            scene.add(frameGroup);
            effectObjects.push(frameGroup);
            
            // 创建建造粒子
            const constructParticles = createConstructParticles();
            scene.add(constructParticles);
            effectObjects.push(constructParticles);
            
            updateEffectDescription('建筑建造', '基础几何框架出现，能量填充的渐进效果');
            
            animateBuildingConstruct();
        }
        
        // 创建建造粒子
        function createConstructParticles() {
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const targets = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // 随机初始位置（上方）
                positions[i * 3] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = 5 + Math.random() * 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                
                // 目标位置（建筑区域）
                targets[i * 3] = (Math.random() - 0.5) * 6;
                targets[i * 3 + 1] = Math.random() * 5;
                targets[i * 3 + 2] = (Math.random() - 0.5) * 6;
                
                // 蓝色调
                colors[i * 3] = 0.2 + Math.random() * 0.3;
                colors[i * 3 + 1] = 0.5 + Math.random() * 0.3;
                colors[i * 3 + 2] = 1.0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'construct-particles',
                targets: targets,
                speeds: new Float32Array(particleCount).fill(0.01 + Math.random() * 0.02),
                building: new Float32Array(particleCount).fill(0)
            };
            
            return particles;
        }
        
        // 建造动画
        function animateBuildingConstruct() {
            const frame = effectObjects.find(obj => obj.userData.type === 'building-frame');
            const particles = effectObjects.find(obj => obj.userData.type === 'construct-particles');
            
            if (!frame || !particles) return;
            
            // 框架生长
            frame.children.forEach(child => {
                if (child.userData.growthPhase < 1) {
                    child.userData.growthPhase += 0.01 * params.speed;
                    child.scale.y = child.userData.growthPhase;
                    child.material.opacity = 0.6 * child.userData.growthPhase;
                }
            });
            
            // 粒子建造
            const positions = particles.geometry.attributes.position.array;
            const targets = particles.userData.targets;
            const speeds = particles.userData.speeds;
            const building = particles.userData.building;
            
            let buildingCount = 0;
            
            for (let i = 0; i < positions.length; i += 3) {
                if (building[i / 3] < 1) {
                    const dx = targets[i] - positions[i];
                    const dy = targets[i + 1] - positions[i + 1];
                    const dz = targets[i + 2] - positions[i + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance > 0.3) {
                        positions[i] += dx * speeds[i / 3] * params.speed;
                        positions[i + 1] += dy * speeds[i / 3] * params.speed;
                        positions[i + 2] += dz * speeds[i / 3] * params.speed;
                        
                        // 下落效果
                        positions[i + 1] -= 0.05 * params.speed;
                    } else {
                        building[i / 3] = 1;
                        buildingCount++;
                    }
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // 消耗资源
            if (buildingCount > 0 && resourceCount > 0) {
                resourceCount -= buildingCount * 0.05 * params.speed;
                resourceCount = Math.max(0, resourceCount);
                updateResourceDisplay();
                
                // 重置粒子
                for (let i = 0; i < building.length; i++) {
                    if (building[i] > 0) {
                        building[i] = 0;
                        positions[i * 3] = (Math.random() - 0.5) * 10;
                        positions[i * 3 + 1] = 5 + Math.random() * 5;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                    }
                }
            }
            
            animationId = requestAnimationFrame(animateBuildingConstruct);
        }
        
        // 创建建筑升级效果
        function createBuildingUpgradeEffect() {
            clearCurrentEffect();
            
            // 创建基础建筑
            const baseGeometry = new THREE.BoxGeometry(4, 4, 4);
            const baseMaterial = new THREE.MeshBasicMaterial({
                color: 0x6b7280,
                transparent: true,
                opacity: 0.8
            });
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 2;
            scene.add(base);
            effectObjects.push(base);
            
            // 创建升级光环
            const upgradeGroup = new THREE.Group();
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const ringGeometry = new THREE.TorusGeometry(3, 0.2, 8, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xfbbf24,
                    transparent: true,
                    opacity: 0.6
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.set(Math.cos(angle) * 3, 2, Math.sin(angle) * 3);
                ring.rotation.z = Math.PI / 2;
                ring.userData = {
                    type: 'upgrade-ring',
                    angle: angle,
                    radius: 3,
                    height: 2,
                    phase: i * Math.PI / 4
                };
                
                upgradeGroup.add(ring);
                effectObjects.push(ring);
            }
            
            upgradeGroup.userData = {
                type: 'upgrade-effect',
                rotation: 0
            };
            
            scene.add(upgradeGroup);
            effectObjects.push(upgradeGroup);
            
            // 创建升级粒子
            const upgradeParticles = createUpgradeParticles();
            scene.add(upgradeParticles);
            effectObjects.push(upgradeParticles);
            
            // 创建等级数字
            const levelCanvas = document.createElement('canvas');
            levelCanvas.width = 256;
            levelCanvas.height = 256;
            const context = levelCanvas.getContext('2d');
            context.fillStyle = '#fbbf24';
            context.font = 'bold 200px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('2', 128, 128);
            
            const levelTexture = new THREE.CanvasTexture(levelCanvas);
            const levelMaterial = new THREE.SpriteMaterial({
                map: levelTexture,
                transparent: true,
                opacity: 0
            });
            
            const levelSprite = new THREE.Sprite(levelMaterial);
            levelSprite.position.set(0, 6, 0);
            levelSprite.scale.set(3, 3, 1);
            levelSprite.userData = {
                type: 'level-indicator',
                opacity: 0,
                targetOpacity: 0
            };
            
            scene.add(levelSprite);
            effectObjects.push(levelSprite);
            
            updateEffectDescription('建筑升级', '建筑发光并旋转，等级提升的数字动画');
            
            animateBuildingUpgrade();
        }
        
        // 创建升级粒子
        function createUpgradeParticles() {
            const particleCount = 150;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 2;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = Math.random() * 4;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                velocities[i * 3] = Math.cos(angle) * 0.02;
                velocities[i * 3 + 1] = 0.02 + Math.random() * 0.02;
                velocities[i * 3 + 2] = Math.sin(angle) * 0.02;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xfbbf24,
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'upgrade-particles',
                velocities: velocities
            };
            
            return particles;
        }
        
        // 升级动画
        function animateBuildingUpgrade() {
            const upgradeGroup = effectObjects.find(obj => obj.userData.type === 'upgrade-effect');
            const particles = effectObjects.find(obj => obj.userData.type === 'upgrade-particles');
            const levelSprite = effectObjects.find(obj => obj.userData.type === 'level-indicator');
            
            if (!upgradeGroup || !particles || !levelSprite) return;
            
            upgradeGroup.userData.rotation += 0.02 * params.speed;
            upgradeGroup.rotation.y = upgradeGroup.userData.rotation;
            
            // 环形运动
            upgradeGroup.children.forEach(ring => {
                ring.userData.phase += 0.05 * params.speed;
                ring.position.x = Math.cos(ring.userData.angle + ring.userData.phase) * ring.userData.radius;
                ring.position.z = Math.sin(ring.userData.angle + ring.userData.phase) * ring.userData.radius;
                ring.position.y = ring.userData.height + Math.sin(ring.userData.phase * 2) * 0.5;
            });
            
            // 粒子上升
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += velocities[i] * params.speed;
                positions[i + 1] += velocities[i + 1] * params.speed;
                positions[i + 2] += velocities[i + 2] * params.speed;
                
                // 螺旋效果
                const angle = Math.atan2(positions[i + 2], positions[i]);
                const newAngle = angle + 0.05 * params.speed;
                const radius = Math.sqrt(positions[i] * positions[i] + positions[i + 2] * positions[i + 2]);
                positions[i] = Math.cos(newAngle) * radius;
                positions[i + 2] = Math.sin(newAngle) * radius;
                
                // 重置粒子
                if (positions[i + 1] > 8) {
                    positions[i] = (Math.random() - 0.5) * 4;
                    positions[i + 1] = 0;
                    positions[i + 2] = (Math.random() - 0.5) * 4;
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // 等级显示
            if (resourceCount > 50) {
                levelSprite.userData.targetOpacity = 1;
            } else {
                levelSprite.userData.targetOpacity = 0;
            }
            
            levelSprite.userData.opacity += (levelSprite.userData.targetOpacity - levelSprite.userData.opacity) * 0.1;
            levelSprite.material.opacity = levelSprite.userData.opacity;
            
            animationId = requestAnimationFrame(animateBuildingUpgrade);
        }
        
        // 创建存储充填效果
        function createStorageFillEffect() {
            clearCurrentEffect();
            
            // 创建存储容器
            const storageGeometry = new THREE.BoxGeometry(6, 6, 6);
            const storageMaterial = new THREE.MeshBasicMaterial({
                color: 0x4b5563,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            
            const storage = new THREE.Mesh(storageGeometry, storageMaterial);
            storage.position.y = 3;
            scene.add(storage);
            effectObjects.push(storage);
            
            // 创建液面
            const liquidGeometry = new THREE.PlaneGeometry(5.8, 5.8);
            const liquidMaterial = new THREE.MeshBasicMaterial({
                color: 0x10b981,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
            liquid.rotation.x = -Math.PI / 2;
            liquid.position.y = 0.1;
            liquid.userData = {
                type: 'storage-liquid',
                level: 0.1,
                targetLevel: 0.1
            };
            
            scene.add(liquid);
            effectObjects.push(liquid);
            
            // 创建流动效果
            const flowGroup = new THREE.Group();
            
            for (let i = 0; i < 5; i++) {
                const flowGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2);
                const flowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x10b981,
                    transparent: true,
                    opacity: 0.8
                });
                
                const flow = new THREE.Mesh(flowGeometry, flowMaterial);
                flow.position.set(
                    (Math.random() - 0.5) * 4,
                    5 + Math.random() * 2,
                    (Math.random() - 0.5) * 4
                );
                flow.userData = {
                    type: 'storage-flow',
                    targetY: 0.1,
                    speed: 0.02 + Math.random() * 0.02
                };
                
                flowGroup.add(flow);
                effectObjects.push(flow);
            }
            
            scene.add(flowGroup);
            effectObjects.push(flowGroup);
            
            updateEffectDescription('能量充填', '储存时的能量充填动画');
            
            animateStorageFill();
        }
        
        // 存储充填动画
        function animateStorageFill() {
            const liquid = effectObjects.find(obj => obj.userData.type === 'storage-liquid');
            const flows = effectObjects.find(obj => obj.children && obj.children[0]?.userData.type === 'storage-flow');
            
            if (!liquid || !flows) return;
            
            // 根据资源更新液面
            liquid.userData.targetLevel = 0.1 + (resourceCount % 100) / 100 * 5.8;
            liquid.userData.level += (liquid.userData.targetLevel - liquid.userData.level) * 0.1;
            liquid.position.y = liquid.userData.level;
            
            // 流动效果
            flows.children.forEach(flow => {
                if (flow.position.y > flow.userData.targetY) {
                    flow.position.y -= flow.userData.speed * params.speed;
                } else {
                    // 重置流动
                    flow.position.y = 5 + Math.random() * 2;
                    flow.position.x = (Math.random() - 0.5) * 4;
                    flow.position.z = (Math.random() - 0.5) * 4;
                }
            });
            
            animationId = requestAnimationFrame(animateStorageFill);
        }
        
        // 创建存储溢出效果
        function createStorageOverflowEffect() {
            clearCurrentEffect();
            
            // 创建满的存储
            const storageGeometry = new THREE.BoxGeometry(6, 6, 6);
            const storageMaterial = new THREE.MeshBasicMaterial({
                color: 0xef4444,
                transparent: true,
                opacity: 0.5,
                wireframe: true
            });
            
            const storage = new THREE.Mesh(storageGeometry, storageMaterial);
            storage.position.y = 3;
            scene.add(storage);
            effectObjects.push(storage);
            
            // 创建溢出粒子
            const overflowParticles = createOverflowParticles();
            scene.add(overflowParticles);
            effectObjects.push(overflowParticles);
            
            // 创建警告光环
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.RingGeometry(3 + i, 3.5 + i, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xef4444,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 6;
                ring.userData = {
                    type: 'warning-ring',
                    phase: i * Math.PI / 3
                };
                
                scene.add(ring);
                effectObjects.push(ring);
            }
            
            updateEffectDescription('存储溢出', '资源过多的警告效果');
            
            animateStorageOverflow();
        }
        
        // 创建溢出粒子
        function createOverflowParticles() {
            const particleCount = 300;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 6;
                positions[i * 3 + 1] = 6;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 6;
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = 0.1 + Math.random() * 0.1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xef4444,
                size: 0.2,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                type: 'overflow-particles',
                velocities: velocities
            };
            
            return particles;
        }
        
        // 溢出动画
        function animateStorageOverflow() {
            const particles = effectObjects.find(obj => obj.userData.type === 'overflow-particles');
            const rings = effectObjects.filter(obj => obj.userData.type === 'warning-ring');
            
            if (!particles || !rings.length) return;
            
            // 粒子溢出
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += velocities[i] * params.speed;
                positions[i + 1] += velocities[i + 1] * params.speed;
                positions[i + 2] += velocities[i + 2] * params.speed;
                
                // 重力
                velocities[i + 1] -= 0.005 * params.speed;
                
                // 重置
                if (positions[i + 1] < 0) {
                    positions[i] = (Math.random() - 0.5) * 6;
                    positions[i + 1] = 6;
                    positions[i + 2] = (Math.random() - 0.5) * 6;
                    velocities[i] = (Math.random() - 0.5) * 0.1;
                    velocities[i + 1] = 0.1 + Math.random() * 0.1;
                    velocities[i + 2] = (Math.random() - 0.5) * 0.1;
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // 警告光环
            rings.forEach(ring => {
                ring.userData.phase += 0.05 * params.speed;
                const scale = 1 + Math.sin(ring.userData.phase) * 0.3;
                ring.scale.set(scale, scale, scale);
                ring.material.opacity = 0.3 + Math.sin(ring.userData.phase * 2) * 0.2;
            });
            
            // 减少资源
            if (resourceCount > 0) {
                resourceCount -= 0.5 * params.speed;
                resourceCount = Math.max(0, resourceCount);
                updateResourceDisplay();
            }
            
            animationId = requestAnimationFrame(animateStorageOverflow);
        }
        
        // 更新效果描述
        function updateEffectDescription(title, description) {
            const descElement = document.getElementById('effectDescription');
            descElement.innerHTML = `<strong>${title}</strong><br>${description}`;
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 特效按钮
            document.querySelectorAll('.effect-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const effect = e.target.dataset.effect;
                    
                    // 更新按钮状态
                    document.querySelectorAll('.effect-button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // 切换特效
                    switch (effect) {
                        case 'normal-collection':
                            createNormalCollectionEffect();
                            break;
                        case 'pure-collection':
                            createPureCollectionEffect();
                            break;
                        case 'building-construct':
                            createBuildingConstructEffect();
                            break;
                        case 'building-upgrade':
                            createBuildingUpgradeEffect();
                            break;
                        case 'storage-fill':
                            createStorageFillEffect();
                            break;
                        case 'storage-overflow':
                            createStorageOverflowEffect();
                            break;
                    }
                });
            });
            
            // 参数滑块
            const speedSlider = document.getElementById('speed');
            speedSlider.addEventListener('input', (e) => {
                params.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value + 'x';
            });
            
            const densitySlider = document.getElementById('density');
            densitySlider.addEventListener('input', (e) => {
                params.density = parseFloat(e.target.value);
                document.getElementById('densityValue').textContent = e.target.value;
            });
            
            // 后处理控制
            const bloomCheckbox = document.getElementById('bloom');
            bloomCheckbox.addEventListener('change', (e) => {
                params.bloom = e.target.checked;
                if (window.bloomPass) {
                    window.bloomPass.enabled = params.bloom;
                }
            });
            
            // 重置相机按钮
            document.getElementById('resetCamera').addEventListener('click', () => {
                camera.position.set(0, 15, 25);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            // 使用后处理或普通渲染
            if (params.bloom && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        
        // 初始化
        init();
    </script>
</body>
</html>